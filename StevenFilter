#!/usr/bin/env python2
#! Copyright (C) 2015-2015 Hack Stuff. All right reserved.
#
# Author : 2015/05 cmj<cmj@cmj.tw>

from multiprocessing import Process
from multiprocessing import Queue as QUEUE	## Since scapy using Queue.py
from flask import Flask
from flask_restful import Resource, Api

class StevenServer(Resource):
	""" StevenServer - The Flask server used in SHIT, connected via Queue """

	def get(self, src):
		import json

		try:
			queue = self.queue
			data = []
			print queue
			while queue.qsize():
				data.append(queue.get())
			data = json.dumps(data)
		except Exception as e:
			data = "resource ({0}) not found {1}".format(src, e)

		return "SHIT - Steven Hack Into This : {0}".format(data)
class StevenCTL(Resource):
	""" StevenCTL - The Flask server usedi in SHIT and control lower-end system """
	def get(self, src):
		import json

		data = []
		if 'client' == src:
			with open('/tmp/dnsmasq.lease') as fd:
				client = fd.read()
			client = [_ for _ in client.split('\n') if _]
			client = [_.split() for _ in client]
			client = {_[3]: {'MAC': _[1], 'IP': _[2]} for _ in client}
			data = json.dumps(client)

		return "SHIT - Steven Hack Into This : {0}".format(data)
class Steven5538(object):
	""" Steven5538 - The package filter used in SHIT """

	FMT = "{0:<10} - {1.src:16} => {1.dst:16} - {2:.32}"
	SRC = ['arp', 'dns', 'telnet', 'http']
	def __init__(self, args):
		self.conf  = args.config
		self.iface = args.iface if args.iface else self.APWiFi['NAME']
		self.args  = args
	def __call__(self):
		""" Run all sniffer backend """
		import select

		print "Start SF ..."
		while True:
			try:
				sniff(iface=self.iface, filter=self.filter, prn=self.handler, store=0)
			except select.error as e:
				continue

	def PKG_01ARP(self, pkg):
		""" Sniffer the ARP query """

		if 'stopARP' in self.conf and self.conf['stopARP']:
			return False
		elif 'Ethernet' != pkg.name or 'ARP' != pkg.payload.name:
			return False

		FMT = "{0:<10} - {1.psrc:16} ({1.hwsrc}) => {1.pdst:16} ({1.hwdst})"
		ret = FMT.format("ARP", pkg.payload)
		self.queue = 'arp', ret
		return True
	def PKG_02DNS(self, pkg):
		""" Sniffer the DNS query """

		if 'stopDNS' in self.conf and self.conf['stopDNS']:
			return False
		elif 'Ethernet' != pkg.name or 'IP' != pkg.payload.name:
			return False
		udp = pkg.payload.payload
		if 'UDP' != udp.name or 53 != udp.dport:
			return False

		dns = pkg.payload
		ret = self.FMT.format("DNS", pkg.payload, dns.qd.qname)
		print ret
		self.queue = 'dns', ret
		return True
	def PKG_03Telnet(self, pkg):
		""" Sniffer the BBS (Telnet) query """

		if 'stopTelnet' in self.conf and self.conf['stopTelnet']:
			return False
		elif 'Ethernet' != pkg.name or 'IP' != pkg.payload.name:
			return False
		tcp = pkg.payload.payload
		if 'TCP' != tcp.name or 23 != tcp.dport:
			return False

		ret = self.FMT.format("BBS", pkg.payload, tcp.payload)
		print ret
		self.queue = 'telnet', ret
		return True
	def PKG_04HTTP(self, pkg):
		""" Sniffer the BBS (Telnet) query """
		import re

		if 'stopHTTP' in self.conf and self.conf['stopHTTP']:
			return False
		elif 'Ethernet' != pkg.name or 'IP' != pkg.payload.name:
			return False
		tcp = pkg.payload.payload
		if 'TCP' != tcp.name or 80 != tcp.dport :
			return False
		elif not tcp.payload:
			return False

		## Simplifer - Get the HTTP/GET header only
		if re.match(r'GET (\S+) HTTP/1.1', tcp.payload.load):
			get = re.search(r'GET (\S+) HTTP/1.1', tcp.payload.load).group(1)
			ret = self.FMT.format("HTTP (GET)", pkg.payload, get)
		elif re.match(r'POST (\S+) HTTP/1.1', tcp.payload.load):
			ret = self.FMT.format("HTTP (POST)", pkg.payload, tcp.payload)
		else:
			return False
		print ret
		self.queue = 'http', ret
		return True
	def PKG_99dump(self, pkg):
		""" Default package handler, always run at-last """
		return True

	@property
	def handler(self, prefix="PKG_"):
		"""
		Package handler, SHOULD return function

		NOTE - Only process the function startswith 'prefix' and exit when
		       function return True. The order is using alphanumeric sort.
		"""
		def _hander_(pkg):
			for _ in sorted(dir(self)):
				if 'stopSniff' in self.conf and self.conf['stopSniff']:
					break
				elif _.startswith(prefix) and getattr(self, _)(pkg):
					break
		return _hander_
	@property
	def filter(self):
		""" The sniffer filter, default is empty string """
		return ""
	@property
	def conf(self):
		return self._conf_
	@conf.setter
	def conf(self, v):
		import re

		with open(v) as fd:
			conf = [_ for _ in fd.read().split('\n') if _]

		conf = [_.strip() for _ in conf if not _.startswith('#')]
		conf = {_.split('=')[0]: '='.join(_.split('=')[1:]) for _ in conf}

		## Remove the quotes
		for _ in conf:
			if re.match(r'(["\']).*?\1', conf[_]):
				conf[_] = conf[_][1:-1]

		self._conf_ = conf
	@property
	def APWiFi(self, path='/sys/class/net'):
		if hasattr(self, "_APWiFi_"):
			return self._APWiFi_

		for wifi in [_ for _ in os.listdir(path)]:
			with open('{0}/{1}/address'.format(path, wifi)) as fd:
				mac = fd.read()
				if mac.startswith(self.conf['MACPREFIX']):
					self._APWiFi_ = {"NAME": wifi, "MAC": mac.strip()}
					return self._APWiFi_
		else:
			return None
	@property
	def queue(self):
		if self.args.flask:
			if not hasattr(self, '_queue_') :
				self._queue_ = {_: QUEUE() for _ in self.SRC}
			return self._queue_
	@queue.setter
	def queue(self, v):
		if self.args.flask:
			proto, data = v
			self._queue_[proto].put(data)

if __name__ == '__main__':
	import argparse, os, sys
	import signal

	if os.getuid() and os.geteuid():
		exit("You need to be root!")

	parser = argparse.ArgumentParser(description="Steven Tool")
	_a = parser.add_argument
	_a("-d", "--debug", action="store_true", default=False,
		help="Enable debug message")
	_a("-f", "--flask", action="store_true", default=False,
		help="Run Flask server")
	_a("-i", "--iface",
		help="Interface you want to sinffer.")
	_a("-a", "--addr", default="0.0.0.0",
		help="Bind host address for SS")
	_a("-p", "--port", default=5538,
		help="Bind the port number for SS")
	_a("-c", "--config", default="fakeAP.conf",
		help="Configure")

	args = parser.parse_args()

	import logging
	# disable scapy ipv6 warning
	logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
	from scapy.all import *

	## Prepare the SIGHUP handler
	steven5538 = Steven5538(args)
	def reloadSteven5538(signum, frame):
		global steven5538
		steven5538.conf = args.config
	signal.signal(signal.SIGHUP, reloadSteven5538)

	## Start sniffer and Flask server
	try:
		if args.flask:
			app = Flask(__name__)
			api = Api(app)

			StevenServer.queue = steven5538.queue
			api.add_resource(StevenServer, '/package/<src>')
			api.add_resource(StevenCTL,    '/ctl/<src>')
			param = {'debug': args.debug, 'host': args.addr, 'port': args.port}
			proc = Process(target=app.run, kwargs=param)
			proc.start()

			if not proc.is_alive():
				raise SystemError("SS is not start")

		steven5538()
	except KeyboardInterrupt as e:
		if args.flask:
			proc.terminate()
	finally:
		if args.flask and proc.is_alive():
			proc.join()

